Метод скользящего среднего
--------------------------
С его помощью можно снизить шумы в данных и сгладить график, выделив общую тенденцию изменения числа запросов.
Метод заключается в том, что создаётся новый массив данных, и в нём значение каждой точки высчитывается как среднее арифметическое предыдущих K значений из исходного набора.
То есть для каждой секунды посчитаем среднее арифметическое от количества запросов за предыдущие K секунд. Этот интервал K будем называть «окном сглаживания». На каждой итерации он смещается, «скользит» — отсюда и название метода.
Например, если данные по нагрузке на сайт для 7 секунд будут такие: 
[4, 3, 8, 1, 5, 6, 3], 
а K=3, то сглаженные значения получатся следующими: 
[5, 4, 4.67, 4, 4.67].
Обратите внимание, что в результирующем массиве будет на K−1 элементов меньше: мы не считаем среднее арифметическое меньше чем для K элементов.

def moving_average(timeseries, K):
    result = []
    for begin_index in range(0, len(timeseries) - K):
        end_index = begin_index + K
        # Просматриваем окно шириной K.
        current_sum = 0
        for v in timeseries[begin_index:end_index]:
            current_sum += v
        current_avg = current_sum / K
        result.append(current_avg)
    return result

Недостаток:
Пусть длина входного списка с данными будет равна N, а окно сглаживания — K. Потребуется N×K операций

Оптимизация: метод двух указателей. Быстрее в K раз
На каждой итерации (кроме первой) можно использовать результат предыдущей и, убрав вложенный цикл, оптимизировать алгоритм.
def moving_average(timeseries, K):
    result = []  # Пустой массив.
    # Первый раз вычисляем значение честно и сохраняем результат.
    current_sum = sum(timeseries[0:K])
    result.append(current_sum / K)
    for i in range(0, len(timeseries) - K):
        current_sum -= timeseries[i]
        current_sum += timeseries[i+K]
        current_avg = current_sum / K
        result.append(current_avg)
    return result 
	
