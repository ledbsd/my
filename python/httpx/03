Используем HTTPX для работы с /api/v1/authentication API
В этом уроке мы будем работать с API /api/v1/authentication на локальном сервере, которое отвечает за аутентификацию. Большинство эндпоинтов тестового сервера требуют авторизации, то есть передачи JWT-токена. Поэтому логично и правильно начинать работу с API именно с аутентификации.

Важно отметить, что работа с аутентификацией — это наиболее частый сценарий в реальных проектах. На коммерческих системах всегда используется тот или иной механизм авторизации, и чтобы полноценно работать с API, необходимо освоить процесс аутентификации.

Доступные методы API
1. /api/v1/authentication/login
Основной метод, отвечающий за процесс аутентификации. На вход принимает email и password. В ответе возвращается:

accessToken — используется для авторизации в других эндпоинтах.

refreshToken — используется для обновления accessToken без необходимости повторной аутентификации.
Используем HTTPX для работы с /api/v1/authentication API
В этом уроке мы будем работать с API /api/v1/authentication на локальном сервере, которое отвечает за аутентификацию. Большинство эндпоинтов тестового сервера требуют авторизации, то есть передачи JWT-токена. Поэтому логично и правильно начинать работу с API именно с аутентификации.

Важно отметить, что работа с аутентификацией — это наиболее частый сценарий в реальных проектах. На коммерческих системах всегда используется тот или иной механизм авторизации, и чтобы полноценно работать с API, необходимо освоить процесс аутентификации.

Доступные методы API
1. /api/v1/authentication/login
Основной метод, отвечающий за процесс аутентификации. На вход принимает email и password. В ответе возвращается:

accessToken — используется для авторизации в других эндпоинтах.

refreshToken — используется для обновления accessToken без необходимости повторной аутентификации.
Чтение Swagger-документации
Очень важно научиться читать документацию Swagger. Зная, как это делать, вы сможете получать всю информацию о тестируемом API, что значительно упрощает тестирование. В уроке "Знакомство с HTTP-протоколом" мы уже разбирали Swagger. Если вы его пропустили, рекомендуем вернуться и ознакомиться.

Работаем с эндпоинтом /api/v1/authentication/login
1. Создаем файл httpx_authentication.py
В корне проекта autotests-api создадим файл:

.
└── autotests-api/
    └── httpx_authentication.py
2. Выполняем POST-запрос
Теперь необходимо выполнить POST-запрос к нашему API:

import httpx  # Импортируем библиотеку HTTPX

# Инициализируем JSON-данные, которые будем отправлять в API
payload = {
    "email": "user@example.com",
    "password": "string"
}

# Выполняем POST-запрос к эндпоинту /api/v1/authentication/login
response = httpx.post("http://localhost:8000/api/v1/authentication/login", json=payload)

# Выводим JSON-ответ и статус-код
print(response.json())
print(response.status_code)
Важно! Email и пароль нужно заменить на данные пользователя, которого вы создали ранее

3. Запуск скрипта
Теперь запустим наш скрипт командой:

python -m httpx_authentication
Если запрос выполнен успешно, в консоли появится следующий вывод:

{
  "token": {
    "tokenType": "bearer",
    "accessToken": "<ACCESS_TOKEN>",
    "refreshToken": "<REFRESH_TOKEN>"
  }
}
200
Поздравляю! Вы успешно отправили первый POST-запрос к API с использованием HTTPX. Однако этот код пока не является автотестом — он лишь выполняет запрос без проверки результата. В дальнейшем мы будем строить автотесты на основе HTTPX.

Работаем с эндпоинтом /api/v1/authentication/refresh
1. Добавляем код для обновления токена
В том же файле httpx_authentication.py добавим следующий код:

import httpx  # Импортируем библиотеку HTTPX

# Данные для входа в систему
login_payload = {
    "email": "user@example.com",
    "password": "string"
}

# Выполняем запрос на аутентификацию
login_response = httpx.post("http://localhost:8000/api/v1/authentication/login", json=login_payload)
login_response_data = login_response.json()

# Выводим полученные токены
print("Login response:", login_response_data)
print("Status Code:", login_response.status_code)

# Формируем payload для обновления токена
refresh_payload = {
    "refreshToken": login_response_data["token"]["refreshToken"]
}

# Выполняем запрос на обновление токена
refresh_response = httpx.post("http://localhost:8000/api/v1/authentication/refresh", json=refresh_payload)
refresh_response_data = refresh_response.json()

# Выводим обновленные токены
print("Refresh response:", refresh_response_data)
print("Status Code:", refresh_response.status_code)
Что изменилось:

Добавлена переменная response_data, чтобы избежать многократных вызовов response.json().

Улучшены комментарии для лучшего понимания кода.

Мы добавили отправку POST-запроса к эндпоинту /api/v1/authentication/refresh. Обратите внимание, откуда мы взяли значение refreshToken — это значение мы получили в ответ на предыдущий запрос к эндпоинту /api/v1/authentication/login. Таким образом, в будущем, когда токен устареет, нам не нужно будет проходить аутентификацию снова, а достаточно выполнить запрос для обновления accessToken.

Важно! Обратите внимание, что перед каждой переменной мы добавляем название эндпоинта, к которому она относится.

Например, при вызове эндпоинта /api/v1/authentication/login мы используем переменные:

login_payload – данные запроса
login_response – объект ответа
login_response_data – распарсенные данные ответа
Аналогично для /api/v1/authentication/refresh:

refresh_payload
refresh_response
refresh_response_data
Это позволяет разграничить обращения к разным ресурсам и избежать конфликтов при хранении данных запросов и ответов. Применяйте этот подход в будущих домашних заданиях и при работе над коммерческими проектами!

2. Запуск скрипта
Выполним команду:

python -m httpx_authentication
В резульате в ответе мы получим следующие вывод в консоль

Login response: {
  "token": {
    "tokenType": "bearer",
    "accessToken": "<ACCESS_TOKEN>",
    "refreshToken": "<REFRESH_TOKEN>"
  }
}
Status Code: 200
Refresh response: {
  "token": {
    "tokenType": "bearer",
    "accessToken": "<ACCESS_TOKEN>",
    "refreshToken": "<REFRESH_TOKEN>"
  }
}
Status Code: 200
Как видно, первый раз мы выполнили запрос, получили ответ с accessToken и refreshToken, затем использовали полученный refreshToken для обновления accessToken. Поэтому во втором ответе accessToken будет новым (обновленным), а refreshToken останется прежним.

У вас может возникнуть вопрос: почему refreshToken не меняется? Дело в том, что у refreshToken также есть срок действия, но он намного дольше, чем у accessToken. Поэтому со временем refreshToken тоже устареет, и нам придется его обновить, а для этого нужно будет пройти аутентификацию заново, чтобы получить новый refreshToken. На первый взгляд это может показаться излишним усложнением, но на самом деле так работают большинство современных приложений, и это сделано в первую очередь для повышения безопасности.

Итоги
Мы научились отправлять запросы к /api/v1/authentication/login для получения accessToken и refreshToken.
Мы разобрались, как использовать /api/v1/authentication/refresh для обновления accessToken.
Мы убедились, что можем работать с API с помощью HTTPX и обрабатывать JSON-ответы.
